<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>discoverpixy: PWR</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">discoverpixy
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">PWR<div class="ingroups"><a class="el" href="group___s_t_m32_f4xx___std_periph___driver.html">STM32F4xx_StdPeriph_Driver</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>PWR driver modules.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for PWR:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group___p_w_r.png" border="0" alt="" usemap="#group______p__w__r"/>
<map name="group______p__w__r" id="group______p__w__r">
<area shape="rect" id="node1" href="group___s_t_m32_f4xx___std_periph___driver.html" title="STM32F4xx_StdPeriph\l_Driver" alt="" coords="5,23,161,65"/><area shape="rect" id="node2" href="group___p_w_r___exported___constants.html" title="PWR_Exported_Constants" alt="" coords="311,5,489,32"/><area shape="rect" id="node4" href="group___p_w_r___private___functions.html" title="PWR_Private_Functions" alt="" coords="319,56,481,83"/></map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group___p_w_r___exported___constants"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_w_r___exported___constants.html">PWR_Exported_Constants</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___p_w_r___private___functions"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_w_r___private___functions.html">PWR_Private_Functions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga7f88bce73931300319824f22578f90de"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7f88bce73931300319824f22578f90de"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PWR_OFFSET</b>&#160;&#160;&#160;(PWR_BASE - <a class="el" href="group___peripheral__memory__map.html#ga9171f49478fa86d932f89e78e73b88b0">PERIPH_BASE</a>)</td></tr>
<tr class="separator:ga7f88bce73931300319824f22578f90de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa1d3d0ea72132df651c76fc1bdffffc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafa1d3d0ea72132df651c76fc1bdffffc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CR_OFFSET</b>&#160;&#160;&#160;(PWR_OFFSET + 0x00)</td></tr>
<tr class="separator:gafa1d3d0ea72132df651c76fc1bdffffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36ff45d972bf94f31f172fd53cf44d23"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga36ff45d972bf94f31f172fd53cf44d23"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>DBP_BitNumber</b>&#160;&#160;&#160;0x08</td></tr>
<tr class="separator:ga36ff45d972bf94f31f172fd53cf44d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga799ab60bdbcfc1076cf2d7f206d09b0c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga799ab60bdbcfc1076cf2d7f206d09b0c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CR_DBP_BB</b>&#160;&#160;&#160;(<a class="el" href="group___peripheral__memory__map.html#gaed7efc100877000845c236ccdc9e144a">PERIPH_BB_BASE</a> + (CR_OFFSET * 32) + (DBP_BitNumber * 4))</td></tr>
<tr class="separator:ga799ab60bdbcfc1076cf2d7f206d09b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17d618eb800c401ef9c6789c9374eaf8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga17d618eb800c401ef9c6789c9374eaf8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PVDE_BitNumber</b>&#160;&#160;&#160;0x04</td></tr>
<tr class="separator:ga17d618eb800c401ef9c6789c9374eaf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49f51ef8285a6be76fd204d49a00709c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga49f51ef8285a6be76fd204d49a00709c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CR_PVDE_BB</b>&#160;&#160;&#160;(<a class="el" href="group___peripheral__memory__map.html#gaed7efc100877000845c236ccdc9e144a">PERIPH_BB_BASE</a> + (CR_OFFSET * 32) + (PVDE_BitNumber * 4))</td></tr>
<tr class="separator:ga49f51ef8285a6be76fd204d49a00709c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad99a3da921e3e64587f6b9505ecba665"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad99a3da921e3e64587f6b9505ecba665"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FPDS_BitNumber</b>&#160;&#160;&#160;0x09</td></tr>
<tr class="separator:gad99a3da921e3e64587f6b9505ecba665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57d7041b5d1bf0ec94fa18152a7fa208"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga57d7041b5d1bf0ec94fa18152a7fa208"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CR_FPDS_BB</b>&#160;&#160;&#160;(<a class="el" href="group___peripheral__memory__map.html#gaed7efc100877000845c236ccdc9e144a">PERIPH_BB_BASE</a> + (CR_OFFSET * 32) + (FPDS_BitNumber * 4))</td></tr>
<tr class="separator:ga57d7041b5d1bf0ec94fa18152a7fa208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15fea9df1b0d324394336f70b319b377"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga15fea9df1b0d324394336f70b319b377"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PMODE_BitNumber</b>&#160;&#160;&#160;0x0E</td></tr>
<tr class="separator:ga15fea9df1b0d324394336f70b319b377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e7c040f5c63f0fce3e274d9a03f1d1a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2e7c040f5c63f0fce3e274d9a03f1d1a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CR_PMODE_BB</b>&#160;&#160;&#160;(<a class="el" href="group___peripheral__memory__map.html#gaed7efc100877000845c236ccdc9e144a">PERIPH_BB_BASE</a> + (CR_OFFSET * 32) + (PMODE_BitNumber * 4))</td></tr>
<tr class="separator:ga2e7c040f5c63f0fce3e274d9a03f1d1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f24ddbcbc5b8d74c0b032cfa53c725a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2f24ddbcbc5b8d74c0b032cfa53c725a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ODEN_BitNumber</b>&#160;&#160;&#160;0x10</td></tr>
<tr class="separator:ga2f24ddbcbc5b8d74c0b032cfa53c725a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ce2817ed3cc064b3577f90cbb23be35"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1ce2817ed3cc064b3577f90cbb23be35"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CR_ODEN_BB</b>&#160;&#160;&#160;(<a class="el" href="group___peripheral__memory__map.html#gaed7efc100877000845c236ccdc9e144a">PERIPH_BB_BASE</a> + (CR_OFFSET * 32) + (ODEN_BitNumber * 4))</td></tr>
<tr class="separator:ga1ce2817ed3cc064b3577f90cbb23be35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2e21cacf95f557d2535d623c41577c2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf2e21cacf95f557d2535d623c41577c2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ODSWEN_BitNumber</b>&#160;&#160;&#160;0x11</td></tr>
<tr class="separator:gaf2e21cacf95f557d2535d623c41577c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4915f7ce72ac67213c7a5b50bce70d54"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4915f7ce72ac67213c7a5b50bce70d54"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CR_ODSWEN_BB</b>&#160;&#160;&#160;(<a class="el" href="group___peripheral__memory__map.html#gaed7efc100877000845c236ccdc9e144a">PERIPH_BB_BASE</a> + (CR_OFFSET * 32) + (ODSWEN_BitNumber * 4))</td></tr>
<tr class="separator:ga4915f7ce72ac67213c7a5b50bce70d54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50e53827046644c175fe431eea5f4261"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga50e53827046644c175fe431eea5f4261"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MRLVDS_BitNumber</b>&#160;&#160;&#160;0x0B</td></tr>
<tr class="separator:ga50e53827046644c175fe431eea5f4261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07027fcac2bdf595eaf9d0933fbdaeec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga07027fcac2bdf595eaf9d0933fbdaeec"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CR_MRLVDS_BB</b>&#160;&#160;&#160;(<a class="el" href="group___peripheral__memory__map.html#gaed7efc100877000845c236ccdc9e144a">PERIPH_BB_BASE</a> + (CR_OFFSET * 32) + (MRLVDS_BitNumber * 4))</td></tr>
<tr class="separator:ga07027fcac2bdf595eaf9d0933fbdaeec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ebe7d965ce7638645ee9a5e35c01be7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7ebe7d965ce7638645ee9a5e35c01be7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LPLVDS_BitNumber</b>&#160;&#160;&#160;0x0A</td></tr>
<tr class="separator:ga7ebe7d965ce7638645ee9a5e35c01be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf91aa0d2f93b4cc91f2f6ca82200faf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadf91aa0d2f93b4cc91f2f6ca82200faf"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CR_LPLVDS_BB</b>&#160;&#160;&#160;(<a class="el" href="group___peripheral__memory__map.html#gaed7efc100877000845c236ccdc9e144a">PERIPH_BB_BASE</a> + (CR_OFFSET * 32) + (LPLVDS_BitNumber * 4))</td></tr>
<tr class="separator:gadf91aa0d2f93b4cc91f2f6ca82200faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga984cbe73312b6d3d355c5053763d499a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga984cbe73312b6d3d355c5053763d499a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CSR_OFFSET</b>&#160;&#160;&#160;(PWR_OFFSET + 0x04)</td></tr>
<tr class="separator:ga984cbe73312b6d3d355c5053763d499a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94fe0520e8f9b71fa2b99c0565ec70ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga94fe0520e8f9b71fa2b99c0565ec70ea"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EWUP_BitNumber</b>&#160;&#160;&#160;0x08</td></tr>
<tr class="separator:ga94fe0520e8f9b71fa2b99c0565ec70ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaff864595f697850b19173b0bca991b0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaaff864595f697850b19173b0bca991b0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CSR_EWUP_BB</b>&#160;&#160;&#160;(<a class="el" href="group___peripheral__memory__map.html#gaed7efc100877000845c236ccdc9e144a">PERIPH_BB_BASE</a> + (CSR_OFFSET * 32) + (EWUP_BitNumber * 4))</td></tr>
<tr class="separator:gaaff864595f697850b19173b0bca991b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a0832bfe421cdd6f2640ffb625cc2d8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1a0832bfe421cdd6f2640ffb625cc2d8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>BRE_BitNumber</b>&#160;&#160;&#160;0x09</td></tr>
<tr class="separator:ga1a0832bfe421cdd6f2640ffb625cc2d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1451a5ec810860a7c2e28c23f0c0e928"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1451a5ec810860a7c2e28c23f0c0e928"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CSR_BRE_BB</b>&#160;&#160;&#160;(<a class="el" href="group___peripheral__memory__map.html#gaed7efc100877000845c236ccdc9e144a">PERIPH_BB_BASE</a> + (CSR_OFFSET * 32) + (BRE_BitNumber * 4))</td></tr>
<tr class="separator:ga1451a5ec810860a7c2e28c23f0c0e928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ee6bf9218f3c476629dd9ee70deef21"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8ee6bf9218f3c476629dd9ee70deef21"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CR_DS_MASK</b>&#160;&#160;&#160;((uint32_t)0xFFFFF3FC)</td></tr>
<tr class="separator:ga8ee6bf9218f3c476629dd9ee70deef21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4a30eebdd1d292331a578b189962e77"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac4a30eebdd1d292331a578b189962e77"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CR_PLS_MASK</b>&#160;&#160;&#160;((uint32_t)0xFFFFFF1F)</td></tr>
<tr class="separator:gac4a30eebdd1d292331a578b189962e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga333526e1d0a5fa4877ad982f9830bbeb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga333526e1d0a5fa4877ad982f9830bbeb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CR_VOS_MASK</b>&#160;&#160;&#160;((uint32_t)0xFFFF3FFF)</td></tr>
<tr class="separator:ga333526e1d0a5fa4877ad982f9830bbeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gad03a0aac7bc3bc3a9fd012f3769a6990"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_w_r.html#gad03a0aac7bc3bc3a9fd012f3769a6990">PWR_DeInit</a> (void)</td></tr>
<tr class="memdesc:gad03a0aac7bc3bc3a9fd012f3769a6990"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deinitializes the PWR peripheral registers to their default reset values.  <a href="#gad03a0aac7bc3bc3a9fd012f3769a6990">More...</a><br /></td></tr>
<tr class="separator:gad03a0aac7bc3bc3a9fd012f3769a6990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0741aea35572b1a75f82b74de12df800"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_w_r.html#ga0741aea35572b1a75f82b74de12df800">PWR_BackupAccessCmd</a> (FunctionalState NewState)</td></tr>
<tr class="memdesc:ga0741aea35572b1a75f82b74de12df800"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disables access to the backup domain (RTC registers, RTC backup data registers and backup SRAM).  <a href="#ga0741aea35572b1a75f82b74de12df800">More...</a><br /></td></tr>
<tr class="separator:ga0741aea35572b1a75f82b74de12df800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga237c143ef6aa55abb8049fa7bf24ab8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_w_r.html#ga237c143ef6aa55abb8049fa7bf24ab8f">PWR_PVDLevelConfig</a> (uint32_t PWR_PVDLevel)</td></tr>
<tr class="memdesc:ga237c143ef6aa55abb8049fa7bf24ab8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the voltage threshold detected by the Power Voltage Detector(PVD).  <a href="#ga237c143ef6aa55abb8049fa7bf24ab8f">More...</a><br /></td></tr>
<tr class="separator:ga237c143ef6aa55abb8049fa7bf24ab8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42cad476b816e0a33594a933b3ed1acd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_w_r.html#ga42cad476b816e0a33594a933b3ed1acd">PWR_PVDCmd</a> (FunctionalState NewState)</td></tr>
<tr class="memdesc:ga42cad476b816e0a33594a933b3ed1acd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disables the Power Voltage Detector(PVD).  <a href="#ga42cad476b816e0a33594a933b3ed1acd">More...</a><br /></td></tr>
<tr class="separator:ga42cad476b816e0a33594a933b3ed1acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5fd6f9336ef8c60d5483651cb0d1a00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_w_r.html#gae5fd6f9336ef8c60d5483651cb0d1a00">PWR_WakeUpPinCmd</a> (FunctionalState NewState)</td></tr>
<tr class="memdesc:gae5fd6f9336ef8c60d5483651cb0d1a00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disables the WakeUp Pin functionality.  <a href="#gae5fd6f9336ef8c60d5483651cb0d1a00">More...</a><br /></td></tr>
<tr class="separator:gae5fd6f9336ef8c60d5483651cb0d1a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83a4d6c5b048f2dab18e8fb04f5368d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_w_r.html#ga83a4d6c5b048f2dab18e8fb04f5368d7">PWR_BackupRegulatorCmd</a> (FunctionalState NewState)</td></tr>
<tr class="memdesc:ga83a4d6c5b048f2dab18e8fb04f5368d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disables the Backup Regulator.  <a href="#ga83a4d6c5b048f2dab18e8fb04f5368d7">More...</a><br /></td></tr>
<tr class="separator:ga83a4d6c5b048f2dab18e8fb04f5368d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada193dea79762f379d4e666a98f28d89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_w_r.html#gada193dea79762f379d4e666a98f28d89">PWR_MainRegulatorModeConfig</a> (uint32_t PWR_Regulator_Voltage)</td></tr>
<tr class="memdesc:gada193dea79762f379d4e666a98f28d89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the main internal regulator output voltage.  <a href="#gada193dea79762f379d4e666a98f28d89">More...</a><br /></td></tr>
<tr class="separator:gada193dea79762f379d4e666a98f28d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga547343cc21342f0f0c66c51cbbf274e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_w_r.html#ga547343cc21342f0f0c66c51cbbf274e9">PWR_OverDriveCmd</a> (FunctionalState NewState)</td></tr>
<tr class="memdesc:ga547343cc21342f0f0c66c51cbbf274e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disables the Over-Drive.  <a href="#ga547343cc21342f0f0c66c51cbbf274e9">More...</a><br /></td></tr>
<tr class="separator:ga547343cc21342f0f0c66c51cbbf274e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d0f38d37bbbe83743da490232c401cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_w_r.html#ga9d0f38d37bbbe83743da490232c401cb">PWR_OverDriveSWCmd</a> (FunctionalState NewState)</td></tr>
<tr class="memdesc:ga9d0f38d37bbbe83743da490232c401cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disables the Over-Drive switching.  <a href="#ga9d0f38d37bbbe83743da490232c401cb">More...</a><br /></td></tr>
<tr class="separator:ga9d0f38d37bbbe83743da490232c401cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbd92c224ccbd9a94ec457faac2841b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_w_r.html#gafbd92c224ccbd9a94ec457faac2841b9">PWR_UnderDriveCmd</a> (FunctionalState NewState)</td></tr>
<tr class="memdesc:gafbd92c224ccbd9a94ec457faac2841b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disables the Under-Drive mode.  <a href="#gafbd92c224ccbd9a94ec457faac2841b9">More...</a><br /></td></tr>
<tr class="separator:gafbd92c224ccbd9a94ec457faac2841b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bca92451d748f2daecb52f241ef509b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_w_r.html#ga2bca92451d748f2daecb52f241ef509b">PWR_MainRegulatorLowVoltageCmd</a> (FunctionalState NewState)</td></tr>
<tr class="memdesc:ga2bca92451d748f2daecb52f241ef509b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disables the Main Regulator low voltage mode.  <a href="#ga2bca92451d748f2daecb52f241ef509b">More...</a><br /></td></tr>
<tr class="separator:ga2bca92451d748f2daecb52f241ef509b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a34c8e7a79adce09059ae87040526c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_w_r.html#ga8a34c8e7a79adce09059ae87040526c0">PWR_LowRegulatorLowVoltageCmd</a> (FunctionalState NewState)</td></tr>
<tr class="memdesc:ga8a34c8e7a79adce09059ae87040526c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disables the Low Power Regulator low voltage mode.  <a href="#ga8a34c8e7a79adce09059ae87040526c0">More...</a><br /></td></tr>
<tr class="separator:ga8a34c8e7a79adce09059ae87040526c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0af19a9fdf0324f2ada60c9bce1aab5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_w_r.html#gaf0af19a9fdf0324f2ada60c9bce1aab5">PWR_FlashPowerDownCmd</a> (FunctionalState NewState)</td></tr>
<tr class="memdesc:gaf0af19a9fdf0324f2ada60c9bce1aab5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disables the Flash Power Down in STOP mode.  <a href="#gaf0af19a9fdf0324f2ada60c9bce1aab5">More...</a><br /></td></tr>
<tr class="separator:gaf0af19a9fdf0324f2ada60c9bce1aab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga694676ac06a9baf50eae45adae0118ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_w_r.html#ga694676ac06a9baf50eae45adae0118ab">PWR_EnterSTOPMode</a> (uint32_t PWR_Regulator, uint8_t PWR_STOPEntry)</td></tr>
<tr class="memdesc:ga694676ac06a9baf50eae45adae0118ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enters STOP mode.  <a href="#ga694676ac06a9baf50eae45adae0118ab">More...</a><br /></td></tr>
<tr class="separator:ga694676ac06a9baf50eae45adae0118ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca6b21d0ecbaf60d866927811e90e08c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_w_r.html#gaca6b21d0ecbaf60d866927811e90e08c">PWR_EnterUnderDriveSTOPMode</a> (uint32_t PWR_Regulator, uint8_t PWR_STOPEntry)</td></tr>
<tr class="memdesc:gaca6b21d0ecbaf60d866927811e90e08c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enters in Under-Drive STOP mode.  <a href="#gaca6b21d0ecbaf60d866927811e90e08c">More...</a><br /></td></tr>
<tr class="separator:gaca6b21d0ecbaf60d866927811e90e08c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00ddae00a9c327b81b24d2597b0052f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_w_r.html#ga00ddae00a9c327b81b24d2597b0052f3">PWR_EnterSTANDBYMode</a> (void)</td></tr>
<tr class="memdesc:ga00ddae00a9c327b81b24d2597b0052f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enters STANDBY mode.  <a href="#ga00ddae00a9c327b81b24d2597b0052f3">More...</a><br /></td></tr>
<tr class="separator:ga00ddae00a9c327b81b24d2597b0052f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa980163a4d83304280ee34942464b4ec"><td class="memItemLeft" align="right" valign="top">FlagStatus&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_w_r.html#gaa980163a4d83304280ee34942464b4ec">PWR_GetFlagStatus</a> (uint32_t PWR_FLAG)</td></tr>
<tr class="memdesc:gaa980163a4d83304280ee34942464b4ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the specified PWR flag is set or not.  <a href="#gaa980163a4d83304280ee34942464b4ec">More...</a><br /></td></tr>
<tr class="separator:gaa980163a4d83304280ee34942464b4ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01c4b2fbd16514b993324e101c3ddf7c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_w_r.html#ga01c4b2fbd16514b993324e101c3ddf7c">PWR_ClearFlag</a> (uint32_t PWR_FLAG)</td></tr>
<tr class="memdesc:ga01c4b2fbd16514b993324e101c3ddf7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the PWR's pending flags.  <a href="#ga01c4b2fbd16514b993324e101c3ddf7c">More...</a><br /></td></tr>
<tr class="separator:ga01c4b2fbd16514b993324e101c3ddf7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>PWR driver modules. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga0741aea35572b1a75f82b74de12df800"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PWR_BackupAccessCmd </td>
          <td>(</td>
          <td class="paramtype">FunctionalState&#160;</td>
          <td class="paramname"><em>NewState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables or disables access to the backup domain (RTC registers, RTC backup data registers and backup SRAM). </p>
<dl class="section note"><dt>Note</dt><dd>If the HSE divided by 2, 3, ..31 is used as the RTC clock, the Backup Domain Access should be kept enabled. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">NewState</td><td>new state of the access to the backup domain. This parameter can be: ENABLE or DISABLE. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga83a4d6c5b048f2dab18e8fb04f5368d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PWR_BackupRegulatorCmd </td>
          <td>(</td>
          <td class="paramtype">FunctionalState&#160;</td>
          <td class="paramname"><em>NewState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables or disables the Backup Regulator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">NewState</td><td>new state of the Backup Regulator. This parameter can be: ENABLE or DISABLE. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga01c4b2fbd16514b993324e101c3ddf7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PWR_ClearFlag </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>PWR_FLAG</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the PWR's pending flags. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PWR_FLAG</td><td>specifies the flag to clear. This parameter can be one of the following values: <ul>
<li>PWR_FLAG_WU: Wake Up flag </li>
<li>PWR_FLAG_SB: StandBy flag </li>
<li>PWR_FLAG_UDRDY: Under-drive ready flag (STM32F42xxx/43xxx devices) </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad03a0aac7bc3bc3a9fd012f3769a6990"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PWR_DeInit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deinitializes the PWR peripheral registers to their default reset values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group___p_w_r_gad03a0aac7bc3bc3a9fd012f3769a6990_cgraph.png" border="0" usemap="#group___p_w_r_gad03a0aac7bc3bc3a9fd012f3769a6990_cgraph" alt=""/></div>
<map name="group___p_w_r_gad03a0aac7bc3bc3a9fd012f3769a6990_cgraph" id="group___p_w_r_gad03a0aac7bc3bc3a9fd012f3769a6990_cgraph">
<area shape="rect" id="node2" href="group___r_c_c.html#gab197ae4369c10b92640a733b40ed2801" title="Forces or releases Low Speed APB (APB1) peripheral reset. " alt="" coords="147,5,335,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga00ddae00a9c327b81b24d2597b0052f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PWR_EnterSTANDBYMode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enters STANDBY mode. </p>
<dl class="section note"><dt>Note</dt><dd>In Standby mode, all I/O pins are high impedance except for:<ul>
<li>Reset pad (still available)</li>
<li>RTC_AF1 pin (PC13) if configured for tamper, time-stamp, RTC Alarm out, or RTC clock calibration out.</li>
<li>RTC_AF2 pin (PI8) if configured for tamper or time-stamp.</li>
<li>WKUP pin 1 (PA0) if enabled. </li>
</ul>
</dd>
<dd>
The Wakeup flag (WUF) need to be cleared at application level before to call this function </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga694676ac06a9baf50eae45adae0118ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PWR_EnterSTOPMode </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>PWR_Regulator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>PWR_STOPEntry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enters STOP mode. </p>
<dl class="section note"><dt>Note</dt><dd>In Stop mode, all I/O pins keep the same state as in Run mode. </dd>
<dd>
When exiting Stop mode by issuing an interrupt or a wakeup event, the HSI RC oscillator is selected as system clock. </dd>
<dd>
When the voltage regulator operates in low power mode, an additional startup delay is incurred when waking up from Stop mode. By keeping the internal regulator ON during Stop mode, the consumption is higher although the startup time is reduced.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PWR_Regulator</td><td>specifies the regulator state in STOP mode. This parameter can be one of the following values: <ul>
<li>PWR_MainRegulator_ON: STOP mode with regulator ON </li>
<li>PWR_LowPowerRegulator_ON: STOP mode with low power regulator ON </li>
</ul>
</td></tr>
    <tr><td class="paramname">PWR_STOPEntry</td><td>specifies if STOP mode in entered with WFI or WFE instruction. This parameter can be one of the following values: <ul>
<li>PWR_STOPEntry_WFI: enter STOP mode with WFI instruction </li>
<li>PWR_STOPEntry_WFE: enter STOP mode with WFE instruction </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaca6b21d0ecbaf60d866927811e90e08c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PWR_EnterUnderDriveSTOPMode </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>PWR_Regulator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>PWR_STOPEntry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enters in Under-Drive STOP mode. </p>
<dl class="section note"><dt>Note</dt><dd>This mode is only available for STM32F42xxx/STM3243xxx devices.</dd>
<dd>
This mode can be selected only when the Under-Drive is already active</dd>
<dd>
In Stop mode, all I/O pins keep the same state as in Run mode. </dd>
<dd>
When exiting Stop mode by issuing an interrupt or a wakeup event, the HSI RC oscillator is selected as system clock. </dd>
<dd>
When the voltage regulator operates in low power mode, an additional startup delay is incurred when waking up from Stop mode. By keeping the internal regulator ON during Stop mode, the consumption is higher although the startup time is reduced.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PWR_Regulator</td><td>specifies the regulator state in STOP mode. This parameter can be one of the following values: <ul>
<li>PWR_MainRegulator_UnderDrive_ON: Main Regulator in under-drive mode and Flash memory in power-down when the device is in Stop under-drive mode </li>
<li>PWR_LowPowerRegulator_UnderDrive_ON: Low Power Regulator in under-drive mode and Flash memory in power-down when the device is in Stop under-drive mode </li>
</ul>
</td></tr>
    <tr><td class="paramname">PWR_STOPEntry</td><td>specifies if STOP mode in entered with WFI or WFE instruction. This parameter can be one of the following values: <ul>
<li>PWR_STOPEntry_WFI: enter STOP mode with WFI instruction </li>
<li>PWR_STOPEntry_WFE: enter STOP mode with WFE instruction </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf0af19a9fdf0324f2ada60c9bce1aab5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PWR_FlashPowerDownCmd </td>
          <td>(</td>
          <td class="paramtype">FunctionalState&#160;</td>
          <td class="paramname"><em>NewState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables or disables the Flash Power Down in STOP mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">NewState</td><td>new state of the Flash power mode. This parameter can be: ENABLE or DISABLE. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa980163a4d83304280ee34942464b4ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FlagStatus PWR_GetFlagStatus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>PWR_FLAG</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether the specified PWR flag is set or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PWR_FLAG</td><td>specifies the flag to check. This parameter can be one of the following values: <ul>
<li>PWR_FLAG_WU: Wake Up flag. This flag indicates that a wakeup event was received from the WKUP pin or from the RTC alarm (Alarm A or Alarm B), RTC Tamper event, RTC TimeStamp event or RTC Wakeup. An additional wakeup event is detected if the WKUP pin is enabled (by setting the EWUP bit) when the WKUP pin level is already high. </li>
<li>PWR_FLAG_SB: StandBy flag. This flag indicates that the system was resumed from StandBy mode. </li>
<li>PWR_FLAG_PVDO: PVD Output. This flag is valid only if PVD is enabled by the <a class="el" href="group___p_w_r___group2.html#ga42cad476b816e0a33594a933b3ed1acd" title="Enables or disables the Power Voltage Detector(PVD). ">PWR_PVDCmd()</a> function. The PVD is stopped by Standby mode For this reason, this bit is equal to 0 after Standby or reset until the PVDE bit is set. </li>
<li>PWR_FLAG_BRR: Backup regulator ready flag. This bit is not reset when the device wakes up from Standby mode or by a system reset or power reset. </li>
<li>PWR_FLAG_VOSRDY: This flag indicates that the Regulator voltage scaling output selection is ready. </li>
<li>PWR_FLAG_ODRDY: This flag indicates that the Over-drive mode is ready (STM32F42xxx/43xxx devices) </li>
<li>PWR_FLAG_ODSWRDY: This flag indicates that the Over-drive mode switcching is ready (STM32F42xxx/43xxx devices) </li>
<li>PWR_FLAG_UDRDY: This flag indicates that the Under-drive mode is enabled in Stop mode (STM32F42xxx/43xxx devices) </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">The</td><td>new state of PWR_FLAG (SET or RESET). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8a34c8e7a79adce09059ae87040526c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PWR_LowRegulatorLowVoltageCmd </td>
          <td>(</td>
          <td class="paramtype">FunctionalState&#160;</td>
          <td class="paramname"><em>NewState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables or disables the Low Power Regulator low voltage mode. </p>
<dl class="section note"><dt>Note</dt><dd>This mode is only available for STM32F401xx/STM32F411xx devices.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">NewState</td><td>new state of the Under Drive mode. This parameter can be: ENABLE or DISABLE. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2bca92451d748f2daecb52f241ef509b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PWR_MainRegulatorLowVoltageCmd </td>
          <td>(</td>
          <td class="paramtype">FunctionalState&#160;</td>
          <td class="paramname"><em>NewState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables or disables the Main Regulator low voltage mode. </p>
<dl class="section note"><dt>Note</dt><dd>This mode is only available for STM32F401xx/STM32F411xx devices.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">NewState</td><td>new state of the Under Drive mode. This parameter can be: ENABLE or DISABLE. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gada193dea79762f379d4e666a98f28d89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PWR_MainRegulatorModeConfig </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>PWR_Regulator_Voltage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures the main internal regulator output voltage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PWR_Regulator_Voltage</td><td>specifies the regulator output voltage to achieve a tradeoff between performance and power consumption when the device does not operate at the maximum frequency (refer to the datasheets for more details). This parameter can be one of the following values: <ul>
<li>PWR_Regulator_Voltage_Scale1: Regulator voltage output Scale 1 mode, System frequency up to 168 MHz. </li>
<li>PWR_Regulator_Voltage_Scale2: Regulator voltage output Scale 2 mode, System frequency up to 144 MHz. </li>
<li>PWR_Regulator_Voltage_Scale3: Regulator voltage output Scale 3 mode, System frequency up to 120 MHz (only for STM32F42xxx/43xxx devices) </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga547343cc21342f0f0c66c51cbbf274e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PWR_OverDriveCmd </td>
          <td>(</td>
          <td class="paramtype">FunctionalState&#160;</td>
          <td class="paramname"><em>NewState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables or disables the Over-Drive. </p>
<dl class="section note"><dt>Note</dt><dd>This function can be used only for STM32F42xxx/STM3243xxx devices. This mode allows the CPU and the core logic to operate at a higher frequency than the normal mode for a given voltage scaling (scale 1, scale 2 or scale 3).</dd>
<dd>
It is recommended to enter or exit Over-drive mode when the application is not running critical tasks and when the system clock source is either HSI or HSE. During the Over-drive switch activation, no peripheral clocks should be enabled. The peripheral clocks must be enabled once the Over-drive mode is activated.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">NewState</td><td>new state of the Over Drive mode. This parameter can be: ENABLE or DISABLE. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9d0f38d37bbbe83743da490232c401cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PWR_OverDriveSWCmd </td>
          <td>(</td>
          <td class="paramtype">FunctionalState&#160;</td>
          <td class="paramname"><em>NewState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables or disables the Over-Drive switching. </p>
<dl class="section note"><dt>Note</dt><dd>This function can be used only for STM32F42xxx/STM3243xxx devices.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">NewState</td><td>new state of the Over Drive switching mode. This parameter can be: ENABLE or DISABLE. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga42cad476b816e0a33594a933b3ed1acd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PWR_PVDCmd </td>
          <td>(</td>
          <td class="paramtype">FunctionalState&#160;</td>
          <td class="paramname"><em>NewState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables or disables the Power Voltage Detector(PVD). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">NewState</td><td>new state of the PVD. This parameter can be: ENABLE or DISABLE. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga237c143ef6aa55abb8049fa7bf24ab8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PWR_PVDLevelConfig </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>PWR_PVDLevel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures the voltage threshold detected by the Power Voltage Detector(PVD). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PWR_PVDLevel</td><td>specifies the PVD detection level This parameter can be one of the following values: <ul>
<li>PWR_PVDLevel_0 </li>
<li>PWR_PVDLevel_1 </li>
<li>PWR_PVDLevel_2 </li>
<li>PWR_PVDLevel_3 </li>
<li>PWR_PVDLevel_4 </li>
<li>PWR_PVDLevel_5 </li>
<li>PWR_PVDLevel_6 </li>
<li>PWR_PVDLevel_7 </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Refer to the electrical characteristics of your device datasheet for more details about the voltage threshold corresponding to each detection level. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafbd92c224ccbd9a94ec457faac2841b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PWR_UnderDriveCmd </td>
          <td>(</td>
          <td class="paramtype">FunctionalState&#160;</td>
          <td class="paramname"><em>NewState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables or disables the Under-Drive mode. </p>
<dl class="section note"><dt>Note</dt><dd>This function can be used only for STM32F42xxx/STM3243xxx devices. </dd>
<dd>
This mode is enabled only with STOP low power mode. In this mode, the 1.2V domain is preserved in reduced leakage mode. This mode is only available when the main regulator or the low power regulator is in low voltage mode</dd>
<dd>
If the Under-drive mode was enabled, it is automatically disabled after exiting Stop mode. When the voltage regulator operates in Under-drive mode, an additional startup delay is induced when waking up from Stop mode.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">NewState</td><td>new state of the Under Drive mode. This parameter can be: ENABLE or DISABLE. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae5fd6f9336ef8c60d5483651cb0d1a00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PWR_WakeUpPinCmd </td>
          <td>(</td>
          <td class="paramtype">FunctionalState&#160;</td>
          <td class="paramname"><em>NewState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables or disables the WakeUp Pin functionality. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">NewState</td><td>new state of the WakeUp Pin functionality. This parameter can be: ENABLE or DISABLE. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun May 10 2015 15:15:20 for discoverpixy by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
